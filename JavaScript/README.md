### 模块说明
本目录下存放的是所有模块文件，脚本主体`main.user.js`只负责定义模块上下文环境、声明模块及提供模块依赖的基础方法，所有功能实现全部转入模块中。  
这意味着从此一般功能性更新一般都不需要修改`main.user.js`代码部分，只需增加版本号、模块等修改元数据部分。

下面是本脚本特有的载入模块方式方法说明：
   1. 本脚本定义了一个专用的载入模块的方法`importModule`用于按需载入其他模块。该方法接收模块名字符串为参数，用于运行声明在`main.user.js`元数据`@resource`标签中的模块。
   2. 该方法可以在模块中使用，按需载入其他模块，使用方法是`BLOD.importModule()`，如果不传入参数，将返回脚本当前已载入模块的集合。

一个模块本质是一个独立正常的js脚本，区别于es6标准的“模块”概念，也不是用户脚本。请像编写一个正常的js文件一样编写模块。当然作为本脚本的模块，肯定需要用到脚本主体提供的数据，使用方法如下：
   1. 脚本主体暴露了一个对象`BLOD`到页面上下文`window`，所有已提供的数据都在该对象上。比如引入模块的方法`importModule`，模块可以直接使用`BLOD.importModule()`。
   2. 这种使用方法是把`BLOD`作为全局变量，浏览器中的全局自然在`window`上。这里强烈建议将`BLOD`先引入模块作用域中再使用，即在模块代码最前面声明`const BLOD = window.BLOD`.
   3. 模块若要提供数据给脚本主体或其他模块，也请挂载到`BLOD`上。比如某模块声明了一个函数`fun1`用来计算md5值，则令`BLOD.fun1 = fun1`即可将函数暴露出去，其他模块可以使用`BLOD.fun1()`的形式使用该函数。

模块可以全局默认载入，也可以按需再用`importModule`方法，但推荐按需载入以减少不必要的资源消耗。如在需要用`BLOD.fun1()`时再使用`importModule`载入声明了函数`fun1`的模块。`importModule`方法具有验重设计，若某模块已载入将忽略，所以大可以在每次使用`BLOD.fun1()`之时都载入一个模块，如果不确定声明了函数`fun1`的模块的话。  
模块本身可能只负责声明函数、对象等数据，具体功能运行还需另外判断运行时机，比如页面载入状态、DOM节点的变化情况，脚本主体定义了几个方法以回调方式运行这些功能。
   - `joinNormal` 方法接收一个回调函数并在重写页面后第一时间调用该回调函数。所有需要尽早运行并且只运行一个的代码请以回调函数的形式传给方法。
      - 如某模块的一个功能`addMsg`是在页面载入的时候弹出一条通知，那么类似的添加回调方法可能是`BLOD.joinNormal(() => addMsg())`。
   - `joinNode` 方法接收一个回调函数并在每次DOM有变化时执行该回调函数，并将`Event`信息作为第一个参数传递给该回调函数。
      - 如某个模块的一个动能`Toast`是在页面插入了一个`class="example"`的div节点时将该节点移除，那么添加回调的方法可能是`BLOD.joinNode((e) => { if(e.target.className=="example") e.target.remove()})`

此外，`xhrhook`模块也提供了添加XMLHttpRequest hook的类似方法`xhrhook`和`jsonphook`，后者用于hook jQuery提供的ajax。具体使用方法参考`xhrhook`模块相关代码，参见下文。

更新模块时请在`main.user.js`元数据`@resource`标签中添加上该模块此次变动的commit散列值，并增加`@version`的版本号以通知用户检查更新。由于模块分发使用的是`jsdelivr`CDN，所以如果不添加散列值会存在24小时以内的延时，如果要立刻刷新请访问对应模块的`purge`服务器，如`https://purge.jsdelivr.net/gh/MotooriKashin/Bilibili-Old/JavaScript/xhrhook.js`

以上就是本脚本模块系统的大概说明，原则上任何单独的功能都可以拆分进一个模块以便维护。

### 功能回调
由于本脚本重写页面必须在大部分功能执行之前执行，而页面重写完成的时机其实是不确定的，所以本脚本定义了几个方法接收回调函数来添加到运行时机队列里，以便各模块适时启动核心功能。
1. `joinNormal`
   - 该方法接收一个回调函数，以在页面重写操作后第一时间运行（此时新的DOM未必完全生成）
   - 使用方法`BLOD.joinNormal(fun)`，`fun`即为所需执行的函数。
   - 示例如上文
   - 这里不适合执行任何需要操作DOM的代码，除非添加其他如`addEventListener`之类的回调。
2. `joinNode`
   - 同样接收一个回调函数，不同的时函数的第一个参数将被传入变动节点的`event`信息。
   - 运行时机是任意`DOM`有变动时都会执行回调，所以在回调函数中请自行用条件判断一下该`DOM`变动的`event`信息是否是合适的运行时机。
   - `event`参数最常用的便是其`target`属性，就是变动的`DOM`对象，如果该对象恰好是需要的，再执行相应的代码。
   - 实例如上文
3. `joinSwitchVideo`
   - 同样接收一个回调函数，以在播放器刷新时运行。切P时播放器会刷新，所以本质是切P监听，适合需要在页面切P时再次运行的代码，此时页面节点基本上都可以正常获取到了（除了播放器上的部分组件按钮，这些可以在此基础上继续使用`setTimeout`等回调延时判断）
4. `xhrhook`
   - 同样接收一个回调函数，以在页面发起**任意**XMLHttpRequest时运行，具体是调用`open`方法时，所以此时可以修改该xhr的链接或者使用进阶方法拦截或者修改xhr返回值。
   - 会传递两个参数给回调函数
      1. XMLHttpRequest对象本身，用于进阶操作。
      2. 以数组形式传递的原`open`方法的参数，其中数组的第二个元素几位xhr的url链接，可以直接重定向。
   - **由于本方法在任意xhr发起时都会调用，所以请务必使用url（即参数2数组的第二的元素）来判断该xhr是否是需要hook的xhr！**
5. `jsonphook`
   - 类似于`xhrhook`，不过hook的时jQuery库所使用的Ajax。
   - 会传递两个参数给回调函数
      1. Ajax对象本身，基本用不到。
      2. Ajax实例对象，其url属性就是目标URL。
   - **由于本方法在任意Ajax发起时都会调用，所以请务必使用url（即参数2数组的第二的元素）来判断该Ajax是否是需要hook的Ajax！